import { BufferAttribute, BufferGeometry, Group, Points, PointsMaterial, Vector3 } from 'three'

type ParticleVert = Vector3 & { velocity: Vector3 }

export default class Stars {
  range = 1e4
  particleCount = 1800
  root = new Group()
  particles = new BufferGeometry()
  material = new PointsMaterial({
    color: 16777215,
    size: 10,
    transparent: true,
  })
  vertices: ParticleVert[] = []

  particleSystem: Points

  constructor() {
    for (let p = 0; p < this.particleCount; p++) {
      const particle = this.vector3InRange(this.range) as ParticleVert
      particle.velocity = this.vector3InRange(1)
      this.vertices.push(particle)
    }
    const positions = new Float32Array(
      this.vertices.flatMap((particle) => [particle.x, particle.y, particle.z]),
    )

    this.particles.setAttribute('position', new BufferAttribute(positions, 3))

    this.particleSystem = new Points(this.particles, this.material)
    this.root.add(this.particleSystem)
  }

  randomInRange(range) {
    return Math.random() * range - range / 2
  }

  vector3InRange(range) {
    return new Vector3(
      this.randomInRange(range),
      this.randomInRange(range),
      this.randomInRange(range),
    )
  }

  update({ params: p }) {
    let pCount = this.particleCount
    this.material.opacity = p.opacity
    if (p.opacity) {
      const positions = this.particles.attributes.position.array
      while (pCount--) {
        const index = pCount * 3 // each vertex is represented by 3 values (x, y, z)
        positions[index + 2] += p.speed
        const velocity = this.vertices[pCount].velocity
        positions[index] += velocity.x * p.velocity
        positions[index + 1] += velocity.y * p.velocity
        positions[index + 2] += velocity.z * p.velocity
        for (let axis = 0; axis < 3; axis++) {
          positions[index + axis] += this.randomInRange(p.randomWalk)
          const position = positions[index + axis]
          if (position < -this.range / 2) {
            positions[index + axis] = this.range / 2
          } else if (position > this.range / 2) {
            positions[index + axis] = -this.range / 2
          }
        }
      }
      this.particles.attributes.position.needsUpdate = true
    }
  }

  // A basic demo of a dynamic config, note the random description
  // getConfig is called any time a sketch is loaded (initial load, or code change)
  getConfig() {
    return {
      defaultTitle: 'Stars',
      description: `A simple star field - don't forget that ${
        this.sayings[Math.floor(Math.random() * this.sayings.length)]
      }`,
      category: 'simple',
      params: [
        {
          title: 'Opacity',
          key: 'opacity',
          defaultValue: 1,
        },
        {
          title: 'Speed',
          key: 'speed',
          defaultValue: 50,
          defaultMin: -100,
          defaultMax: 100,
        },
        {
          title: 'Velocity',
          key: 'velocity',
          defaultValue: 0,
          defaultMin: -100,
          defaultMax: 100,
        },
        {
          title: 'Random Walk',
          key: 'randomWalk',
          defaultValue: 0,
          defaultMin: 0,
          defaultMax: 100,
        },
      ],
      shots: [],
    }
  }

  // generated by copilot after the first string was strung <3
  sayings = [
    'you are a star',
    'you are amazing',
    'you are loved',
    'you are awesome',
    'you are special',
    'you are unique',
    'you are important',
    'you are appreciated',
    'you are valued',
    'you are cherished',
    'you are respected',
    'you are admired',
    'you are celebrated',
    'you are a gift',
    'you are a treasure',
    'you are a blessing',
    'you are a miracle',
    'you are a wonder',
    'you are a masterpiece',
    'you are a work of art',
  ]
}
